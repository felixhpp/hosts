package main

import (
	"bufio"
	"bytes"
	"io/ioutil"
	"log"
	"math/rand"
	"net/http"
	"net/url"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"runtime"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/parnurzeal/gorequest"
	yaml "gopkg.in/yaml.v1"
)

//Target 类型
type Target struct {
	Host string `json:"host"`
}

//Config 配置
type Config struct {
	Hosts string `yaml:"hosts"`
}

var cfg *Config
var cfgFilename = "config.yaml"

//getConfig 解析配置
func getConfig() *Config {
	filename, _ := filepath.Abs(cfgFilename)
	yamlFile, err := ioutil.ReadFile(filename)
	if err != nil {
		panic(err)
	}
	var c *Config
	err = yaml.Unmarshal(yamlFile, &c)
	if err != nil {
		panic(err)
	}
	cfg = c
	return cfg
}

func main() {
	start := time.Now()
	log.Println("程序执行中，大概需要一分钟，请耐心等待...")
	cfg := getConfig()
	hosts := strings.Split(cfg.Hosts, "|")

	var finals []string
	jobs := make(chan string, 200)
	results := make(chan string, 200)

	for w := 0; w < 10; w++ {
		go worker(jobs, results)
	}

	all := getDomains(hosts)
	finals = doAction(all, jobs, results)
	doWrite(finals)

	log.Println("解析目标网站中链接，请等待...")
	var wg sync.WaitGroup
	at := make([][]string, len(hosts))
	for i, v := range hosts {
		wg.Add(1)
		go func(i int, x string) {
			at[i] = getURL(x)
			wg.Done()
		}(i, v)
	}
	wg.Wait()

	k := removeDuplicate(sliceCombine2(at))
	t := doAction(k, jobs, results)
	finals = removeDuplicate(sliceCombine1(finals, t))
	doWrite(finals)
	closeChannel(jobs, results)
	log.Printf("设置完成，可以正常访问了。耗时: %.2fs\n", time.Now().Sub(start).Seconds())
}

func worker(jobs <-chan string, results chan<- string) {
	for j := range jobs {
		h := &Target{Host: j}
		results <- getIP(h)
	}
}

func getDomains(s []string) (out []string) {
	var temp []string
	var x string
	for _, v := range s {
		temp = append(temp, v)
		if arr := strings.Split(v, "."); arr[0] == "www" {
			for i := 1; i < len(arr); i++ {
				x += arr[i] + "."
			}
			temp = append(temp, strings.TrimSuffix(x, "."))
			x = ""
		}
	}
	out = removeDuplicate(temp)
	return
}

func getURL(targetURL string) (result []string) {
	var before, after []string
	_, body, err := gorequest.New().
		Get("https://"+targetURL).
		Retry(3, 3*time.Second, http.StatusBadRequest, http.StatusInternalServerError).
		End()
	if err != nil {
		log.Println(err)
	} else {
		r, _ := regexp.Compile("(href|src)=\"[^\"]*\"")
		before = r.FindAllString(body, -1)
	}
	for _, v := range before {
		v = strings.TrimPrefix(v, "href=\"")
		v = strings.TrimPrefix(v, "src=\"")
		v = strings.TrimSuffix(v, "\"")
		if x, err := url.ParseRequestURI(v); err == nil {
			after = append(after, x.Host)
		}
	}
	result = removeDuplicate(after)
	return
}

func getIP(h *Target) (out string) {
	_, body, err := gorequest.New().
		Post("http://ping.eu/action.php?atype=1").
		Send(&h).
		Set("Host", "ping.eu").
		Set("Origin", "http://ping.eu").
		Set("Referer", "http://ping.eu/ping/").
		Set("X-Forwarded-For", fakeIP()).
		Set("Content-Type", "application/x-www-form-urlencoded").
		Set("User-Agent", "Mozilla/5.0 (iPad; CPU OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1").
		Retry(3, 10*time.Second, http.StatusBadRequest, http.StatusInternalServerError).
		End()
	if err != nil {
		log.Println(err)
	} else {
		r, _ := regexp.Compile("(25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)(\\.(25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)){3}: icmp")
		ip := r.FindString(body)
		ip = strings.TrimSuffix(ip, ": icmp")
		if ip != "" {
			out = ip + "\t" + h.Host
		}
	}
	return
}

func doAction(s []string, inS, outS chan string) (f []string) {
	for _, v := range s {
		inS <- v
	}
	for range s {
		f = append(f, <-outS)
	}
	f = removeDuplicate(f)
	return
}

func doWrite(input []string) {
	f, err := os.Open("base")
	if err != nil {
		log.Println(err.Error())
	}
	defer f.Close()

	c, err := ioutil.ReadAll(bufio.NewReader(f))
	if err != nil {
		log.Println(err.Error())
	}

	var headLine, baseLine, content string
	headLine = "\r\n\r\n# Automatically generated by https://github.com/henson/hosts\r\n# Last updated at " + time.Now().Format("2006-01-02 15:04:05") + "\r\n# Hosts Start"
	baseLine = "\r\n# Hosts End"

	for _, v := range input {
		content += "\r\n" + v
	}

	z := bytesCombine(c, []byte(headLine), []byte(content), []byte(baseLine))
	if runtime.GOOS == "windows" {
		if ioutil.WriteFile("C:\\Windows\\System32\\drivers\\etc\\hosts", z, 0644) == nil {
			log.Println("写入文件成功")
			cmd := exec.Command("ipconfig", "/flushdns")
			if err := cmd.Run(); err != nil {
				log.Println(err.Error())
			} else {
				log.Println("新 DNS 解析生效")
			}
		}
	} else {
		if ioutil.WriteFile("hosts", z, 0644) == nil {
			log.Println("写入文件成功")
			if exec.Command("sudo", "cp", "hosts", "/etc/").Run() == nil {
				log.Println("hosts 替换成功")
			}
			if exec.Command("sudo", "/etc/init.d/networking", "restart").Run() == nil {
				log.Println("新 DNS 解析生效")
			}
		}
	}
}

func closeChannel(s ...chan string) {
	for _, v := range s {
		close(v)
	}
}

// 去空去重
func removeDuplicate(arr []string) []string {
	resArr := make([]string, 0)
	tmpMap := make(map[string]interface{})
	for _, val := range arr {
		if val != "" {
			if _, ok := tmpMap[val]; !ok {
				resArr = append(resArr, val)
				tmpMap[val] = struct{}{}
			}
		}
	}
	return resArr
}

// 拼合[]byte切片组
func bytesCombine(pBytes ...[]byte) []byte {
	return bytes.Join(pBytes, []byte(""))
}

func sliceCombine1(s ...[]string) (r []string) {
	for _, v := range s {
		r = append(r, v...)
	}
	return
}

func sliceCombine2(s [][]string) (r []string) {
	for _, v := range s {
		r = append(r, v...)
	}
	return
}

func fakeIP() (result string) {
	a := strconv.Itoa(rand.Intn(255))
	b := strconv.Itoa(rand.Intn(255))
	c := strconv.Itoa(rand.Intn(255))
	d := strconv.Itoa(rand.Intn(255))
	result = a + "." + b + "." + c + "." + d
	return
}
